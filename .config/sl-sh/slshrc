;; This is a config file for people named price, you would put it in ~/.config/slsh/slshrc to use it.
(core::ns-import 'core)
(ns-import 'shell)

;; gpwclark TODOs
;; getopts!
;; - hash-hashkey -> hashkey built in [(and (hash? test-result) (hash-haskey test-result :error))]
;; - get slsh in AUR
;; USE empty-seq? instead of (when not nil) for looping over list
;; - range? fcn
;; - make cond macro?
;; - need clojure's threading macro support but you know, we'll call it
;;		"weaving" (which is sometimes used in AOP but not nearly as overlaoded as
;;		the word "thread" in programming.)
;; - bash completion not working with git checkout and filepaths?
;; - rewrite bash so we don't have gpl in here?
;; - CI on github? possible?
;; - track bkrd processes in PS1? could be helpful?
;; - address exec-hook.lisp stuff


;; bash-completions.lisp is located in `contrib/gpwclark`
(load "~/.config/sl-sh/bash-completions.lisp")

;; overrides exec hook to use endfix notation
(endfix-on)

;; shell helpers {{{
	(defn dush
		"With no arguments: alias for du ./* -sh
		With any args: provides size of each provided argument
		Section: shortcut"
		(&rest paths)
		(if (= 0 (length paths))
			(du ./* -sh)
			(for path paths (du path -sh))))

	(defn pgz
		"Parallelized gzip.
		cores:
			use lscpu to determine # of cores on box
		compression-ratio:
			- 1 fastest speed, worst compression
			- 9 slowest speed, most compression
			- default is 6

		Section: shortcut"
		(target-name cores compression-ratio &rest dirs)
			(out>
				target-name
				(|
					(eval (str "tar cf - " (str-cat-list " " dirs)))
					(eval (str "pigz  -p " cores  " -" compression-ratio)))))
	(defn dpgz
	"Parallelized un gzip.
	cores:
		use lscpu to determine # of cores on box
	Section: shortcut"
			(target-name cores)
				(pigz --keep --decompress --processes cores target-name))

	(defn fullfp
	"Give me a relative filepath and I'll give you an absolute filepath!
	Section: shortcut"
		(filepath)
		(find $PWD -name filepath))

	(defn most-recent-ls-thing ()
		(str-split " " (str-trim (str (| (/sbin/ls -at) ( tr "\n" " ") (tr -s "[[:blank:]]"))))))

	(defn lftail
		"Provide string to filter results of ls. Newest file that contains
		that string is then \"tail -f\"'d

		Section: shortcut"
		(str-to-tail-f) (progn
		(defq matching-list (filter (fn (x) (and (fs-file? x) (str-contains str-to-tail-f x))) (most-recent-ls-thing)))
		(println "list match: " matching-list)
		(defq tail-target (first matching-list))
		(println "tail -f " tail-target)
		(tail -f tail-target)))

	(defn cdt
	"cd into the directory with the most recent timestamp
	Section: shortcut
	"
		()
		(progn
			(defq most-recent-dir
				(first (filter (fn (x) (and (fs-dir? x) (not (= ".." x)) (not (= "." x)))) (most-recent-ls-thing))))
			(eval `(cd ,most-recent-dir))))

	;; stdin to clipboard
	(alias sc (str-trim (xclip -selection c)))

	;;put my pwd in my clipboard
	(alias this (| (pwd) (sc)))

	;; access zsh history search
	(defn zh ()
		(progn
			(defq raw-zsh-str (str (| (cat ~/.zsh_history) (fzf-tmux))))
			(eval (str "(loose-symbols (" (str-cat-list ";" (rest (str-split ";" raw-zsh-str))) "))"))))

	(defn stripcolor (&rest args)
		(if (< (length args) 2)
			(perl -pe "s/\e\[?.*?[\@-~]//g']" (nth 0 ars))
			(err "Only accepts 0 or 1 arguments")))

	;; all find . -iname &rest
	(defn ifind (&rest args)
	(if (< (length args) 2)
		(| (find . -iname (str (nth 0 args))))
		(err "Only accepts 0 or 1 arguments")))


	;;results feed into vim
	(defn vimifind (&rest args)
		(if (< (length args) 2)
			(let
				((vimargs (str-split
					" "
					(str-trim (str (| (find $PWD -iname (nth 0 args)) (tr "\n" " ")))))))
				(progn
					(eval `(vim ,@vimargs))))
			(err "Only accepts 0 or 1 arguments")))

;; }}}

;; java helpers {{{
;;gradle build
(defn g (&rest args)
(let ((log-out-file "last_build.log"))
(progn
	(|
		(defq gradle-proc (eval (append '(./gradlew) args)))
		(tee log-out-file)
	)
	(defq gradle-ret-code (wait gradle-proc))
	(defq log-out-txt (str "Build log in " log-out-file "\n" (| (cat log-out-file) (tail -n 2) (head -n 2))))
	(defq proj-name (str (basename $PWD)))
	(if (= 0 gradle-ret-code)
		(nss-pass (str "PASS! - " proj-name) log-out-txt)
		(nss-fail (str "FAIL! - " proj-name) log-out-txt))
	(= 0 gradle-ret-code))))

(defmacro javad
	"Start the jvm in debug mode, will hang until a debugger connects to jvm
	on port 5005"
	(&rest args)
		`(java "-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005" ,@args))
;; }}}


;; custom env settings {{{
	(export 'EDITOR "vim")
	;; use vi keybindings on cli
	(hash-set! *repl-settings* :keybindings :vi)
	(hash-set! *repl-settings* :vi_esc_sequence '("jk" 200))
	(hash-set! *repl-settings* :vi-normal-prompt-prefix (str (bg-color-rgb 255 140 0)))
	(hash-set! *repl-settings* :vi-normal-prompt-suffix (str shell::*bg-default*))

	;; syntax highlighting
	(syntax-on)

	;; tweak token colors
	(setq tok-default-color shell::*fg-magenta*)
	(setq tok-sys-command-color shell::*fg-green*)
	(setq tok-string-color (fg-color-rgb 255 128 0))

	(error-stack-on)

	(hash-set! *repl-settings* :max-history 10000)
;; }}}

;; quality of shell life {{{
	(alias :q (exit))

	(alias ls (lsd))

	;; betterer ls
	(alias ll (lsd -haltr))

	;; Replace cd with a version that also runs ls after.
	;; Macro to let un-expanded args go to root::cd.
	(defmacro cd (&rest args) (progn
		(if (= (length args) 0)
			(and (root::cd) (ls .))
			(if (= (length args) 1)
				(and (root::cd (first args)) (ls .))
				(err "I take zero or one argument.")))
		nil))
	;; Abuse register-alias to have better syntax highlighting for cd.
	(register-alias 'cd)
;; }}}

;; quality of life {{{
	;; check spelling
	(defn spl (word)
		(println (str (| (echo (str word)) (aspell -a)))))

	(defn weather()
		(curl wttr.in))
;; }}}

;; notification helpers {{{
	(defn persist-nss (&rest args)
		(if (= (length args) 2)
			(eval `(notify-send -t 0 ,@args --icon=system-software-update))
			(err "takes 2 arguments")))

	(defn nss-pass (&rest args)
		(if (= (length args) 2)
			(eval `(notify-send -t 0 ,@args --icon=face-wink))
			(err "takes 2 arguments")))

	(defn nss-fail (&rest args)
		(if (= (length args) 2)
			(eval `(notify-send -t 0 ,@args --icon=process-stop))
			(err "takes 2 arguments")))

	;; fun, persistent notify send!
	(defn pnss (&rest args)
		(if (> (length args) 1)
			(err "I take one fucking argument dude.")
			(persist-nss (nth 0 args) (str (fortune)))))

	;;tell me about it!
	(defn tmai ()
		(progn
			(defq last-ret-val *last-status*)
			(pnss (str "Last program exit status: " last-ret-val  "."))
			last-ret-val))
;; }}}

;; tmux aliases {{{
	(alias tmuxls (tmux list-sessions))

	(alias tmuxnew (tmux new -s))

	(alias tmuxkill (tmux kill-session -t))

	(defn tmuxopen (&rest args)
		(if (= (length args) 1)
			(progn
				(defq tmux-ret-code (tmux a -t (first args)))
				(if (= 0 tmux-ret-code)
					0
					(tmuxnew (first args))))
			(err "Takes one argument, name of tmux session to create.")))
;; }}}

;; time helpers {{{
	;; epoch in milliseconds
	(alias epochms (str-trim (| (date +%s%N) (cut -b1-13))))

	(defn datest ()
		(let-env ((TZ ":America/New_York"))
		 (date)))

	;; takes epock IN SECONDS and converts to nice date time
	(defn fromepoch (time)
		(date -d (str "@" time)))

	(defn timestamp ()
	(date +%Y%m%d_%H%M%S))
;; }}}

;; prompt {{{
	(defn get_pwd ()
		(str-cat-list "/" (str-split "/" (str-replace (str-trim $PWD) $HOME "~"))))

	;;TODO maybe a version of this that strips out all non first/last char consononants
	(defn path_list_trunc (plist)
		(if (> (length plist) 1)
			(if (> (length (first plist)) 0)
				(vec-insert-nth! 0 (str-sub 0 1 (first plist)) (path_list_trunc (rest plist)))
				(path_list_trunc (rest plist)))
			plist))

	(defn smaller_path (dir)
		(str-cat-list "/" (path_list_trunc (str-split "/" (str-replace (str-trim dir) $HOME "~")))))

	(defn set_prompt_tail ()
		(if (= *last-status* 0) "\x1b[39m❄ >\x1b[39m " (str "\x1b[31m(" *last-status* ")❄ >\x1b[39m ")))

	(defn parse_git_branch () (let ((branch))
		(err>null (setq branch (str (git rev-parse --abbrev-ref HEAD))))
		(if (= branch "")
			(str "")
			(str "(" (str-trim branch) ")"))))

	;; prompt ensures
	;;	1. always a new line above prompt
	;;	2. if pushd has been used displays in reverse order dirs to popd
	;;	3. current path
	;;	4. if in git dir display current branch
	;;	5. cursor on near empty line
	(defn __prompt ()
		(progn
			;; set $la to be the last argument of the last command.
			(export 'la (str (first (str-rsplitn 2 " " *last-command*))))
			(str
				"\n"
				(if (> (length (get-dirs)) 0)
					(str (map! smaller_path (reverse (get-dirs))))
					"")
				"\n\r" "\x1b[32m[slsh]:" $HOST ": \x1b[34m" (str-trim (get_pwd)) "/ \x1b[37m" (parse_git_branch) "\n"
				(set_prompt_tail))))
;; }}}

;; i'm fun {{{
	(println "		Hey, hey, hey. Don't be mean.")
	(println "		We don't have to be mean because,")
	(println "		remember, no matter where you go,")
	(println "		there you are.")
	(println (str "			- Buckaroo Banzai (" (str-trim (| (cat ~/.local/share/sl-sh/history) (grep -v "<ctx>") (wc -l))) ")"))
	(intern-stats)
;; }}}

;; machine specific {{{

(defq custom-lisp-config (str "~/.config/sl-sh/" (str-trim (str (cat /etc/hostname))) ".lisp"))
(if (fs-exists? custom-lisp-config)
	(load custom-lisp-config)
	(println (str shell::*fg-red* "Failed loading sl-sh config at " custom-lisp-config shell::*fg-default*)))

;;}}}

;; user ns docs {{{

	(pushd "/home/price/development/slsh/docs/")
	(load "/home/price/development/slsh/docs/mk-docs.lisp")

	(defn filter-non-user-forms (sym-list) (progn
		(loop (sym-list namespaces) (sym-list '("root" "core" "shell"))
		;;(loop (sym-list namespaces) (sym-list (append! (ns-symbols 'shell) (ns-symbols 'core) (ns-symbols 'root)))
			(if (empty-seq? namespaces)
				sym-list
				(progn
					(setq sym-list (filter
						(fn (x) (not (in? (ns-symbols (to-symbol (first namespaces))) x)))
						sym-list))
					(recur sym-list (rest namespaces)))))))

	(defn filter-undocable-forms (sym-list)
		(filter (fn (x)
			(and
				(not (= x '*ns*))
				(not (= x 'tok-slsh-form-color))
				(not (= x 'tok-slsh-fcn-color))
				(not (= x 'tok-default-color))
				(not (= x 'tok-sys-command-color))
				(not (= x 'tok-sys-alias-color))
				(not (= x 'tok-string-color))
				(not (= x 'tok-invalid-color))
				(not (= x 'custom-lisp-config))
				;;TODO should not exclude last-status OR export
				(not (= x '*last-status*))
				(not (= x '*repl-settings*))
				(not (= x '__completion_hook))
				(not (= x '__line_handler))
				(not (= x '__exec_hook))
				(not (= x '__prompt))
				(not (= x 'export))
				(not (= x 'args))))
			sym-list))

	;;TODO ideally this would live in mk-docs.lisp
	;; and :user would be an option as param fo mkdocs::get-doc-list-for
	(defn list-of-user-slsh-syms () (progn
		(defq user-syms (list))
		(for a-ns (filter
					(fn (x) (not (in? '("root" "shell" "core" "mkdocs" "docparse" "docmd") x)))
					(ns-list))
			(append! user-syms (ns-symbols (to-symbol a-ns))))
		(filter-undocable-forms (filter-non-user-forms user-syms))))

	(defq all-docstrings (map! (fn (x) (doc (to-symbol x))) (list-of-user-slsh-syms)))
	(println (mkdocs::make-md-file-with-docstrings "/home/price/development/slsh/docs/index.markdown" all-docstrings))
	(popd)

;; }}}
