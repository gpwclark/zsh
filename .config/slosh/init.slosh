;; any accompanying functions OR files might be referring to slosh files that live
;; here: https://github.com/gpwclark/so-lush/tree/main/.config/so-lush/slosh
;; or here: https://github.com/gpwclark/zsh/tree/main/.config/slosh
;; *** I highly recommend using vcsh and mr to manage [all your (repos/dotfiles) ***
(prn (version))

(def *git-prompt-features* (str))

;;;; Common imports and env setup.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; load the core lib
(load "core.slosh")
(load "iterator.slosh")
(import iter)
;; load and activate syntax highlighting on the prompt
(load "sh-color.slosh")
(load "color-palette.slosh")

(def so-lush (str (env "HOME") "/.config/so-lush/slosh/"))
(when (fs-exists? so-lush)
	(do
		(vec-push! *load-path* so-lush)
		(prn "load-path*:" *load-path*)))


(when (= :linux (platform))
	(let (file-name (str (temp-dir) "/twenty-twenty-twenty-timer.pid")
	      file-written (fs-exists? file-name))
	      (if file-written 
		(do
			(prn "File Exists"))
		(do
			(prn "File does not exist")
			(let (file (fopen file-name :create :truncate)
			[out pid] $(systemd-run --user --on-boot=1200 --on-unit-active=1200 /bin/notify-send "20/20/20 RULE" "Every 20 minutes look at something 20 ft away for 20 seconds\nEvery 20 minutes look at something 20 ft away for 20 seconds\nEvery 20 minutes look at something 20 ft away for 20 seconds\nEvery 20 minutes look at something 20 ft away for 20 seconds\nEvery 20 minutes look at something 20 ft away for 20 seconds\nEvery 20 minutes look at something 20 ft away for 20 seconds\nEvery 20 minutes look at something 20 ft away for 20 seconds\n" -t 20000 :>))
				
				(defer (fclose file))
				(fprn file pid))))))

(when (fs-exists? so-lush)
	(do
        (load "shell-docs.slosh")
        (import shell-docs)))


;;;; common helpers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#%
Usage: (file-to-str /path/to/file)

Get contents of file to string.

Section: user-shell

%#
(defn file-to-str (file)
     (let (tst-file-read (fopen file :read))
        (defer (fclose tst-file-read))
        (iter::reduce
            (iter::iter tst-file-read)
            ""
            (fn (x y)
                (if (= (len x) 0)
                    (str x (str-trim y))
                    (str x (str-trim y) \newline))))))


(defn parse-git-branch ()
	(let (branch ($sh "git rev-parse --abbrev-ref HEAD 2>/dev/null")
			branch-name (env "BRANCH_NAME")
			branch-name (if (nil? branch-name) "" branch-name))
	(str-push! *git-prompt-features* "\n - LAST BRANCH AWARE: LAST_BRANCH env var has value of branch last checked out.")
	(if (= branch "")
		(do (set-env "BRANCH_NAME" "") (unset-env "LAST_BRANCH") "")
		(do
		    (when (and ;; branch provided IS new
				(not (= branch branch-name))
				;; branch provided is not equal to last
				(not (= branch branch-name)))
			    (set-env "LAST_BRANCH" branch-name))
		    (set-env "BRANCH_NAME" branch)
		    (str ": " branch)))))

(defn get-pwd ()
	(str-replace (env 'PWD) (env 'HOME) "~"))

(defn set-prompt-tail (last-status color-prompt)
    (let (debug (if (str-contains (version) "debug") "[DEBUG]" "")
         status (if (= last-status 0) "" (str *fg-red* "(" last-status ")" *fg-default*))
	 alt-repo-val (env "SLOSH_ALT_REPO")
	 alt-work-tree (if (or (nil? alt-repo-val) (= "" (str-trim alt-repo-val))) "" (str "\n" *fg-red* "(altrepo): " (env "SLOSH_ALT_REPO") *fg-default*)))
    (if (= *euid* 0)
        (str *fg-red* alt-work-tree status "\n" *fg-red* debug "λ #" *fg-default* " ")
        (str color-prompt alt-work-tree status "\n" color-prompt debug "λ >" *fg-default* " "))))

(str-push! *git-prompt-features* " - ALTREPO: adds a line to the command prompt when an altrepo's git dir is being used, indicating the current working directory is not using .git to inform the git cmd.")

#%
Usage: (file-to-str "/path/to/file")

Get contents of file to string.

Section: user-shell
%#
(defn file-to-str (file)
     (let (tst-file-read (fopen file :read))
        (defer (fclose tst-file-read))
        (iter::reduce
            (iter::iter tst-file-read)
            ""
            (fn (x y)
                (if (= (len x) 0)
                    (str x (str-trim y))
                    (str x (str-trim y) \newline))))))

#|
(defn stripcolor
        "remove all color codes from any strings
        Section: user-shell"
        (&rest args)
        (if (< (length args) 2)
                $(perl -pe "s/\e\[?.*?[\@-~]//g']" $((nth 0 ars)))
                (err "Only accepts 0 or 1 arguments")))

;; all find . -iname &rest
(defn ifind
        "pass in a string. list all files in vim whose filenames contain that string.
        Section: user-shell"
        (&rest args)
        (let (find-str
                        (apply str #\*
                                (collect (iterator::interleave args (repeat #\* (length args))))))
                $(find $PWD -iname $find-str)))
|#

;; TODO trying to figure out how to make the body of get-hostname a macro
(defmacro str-str-rep (given)
	(let (new-given `(cons ~given ":>"))
	`(prn "str " ~new-given)))

(defn get-hostname ()
    (let ([pid, out] $(cat /etc/hostname :> 2>&1))
        (iter::reduce (iter::iter out) "" (fn (x y) (if (= (len x) 0) (str x (str-trim y)) (str x (str-trim y) \newline))))))


;; want my "random colorizer like before"
;; want to get a nice color pallet like:
;; >>(fg-color-rgb 128 128 128)
;; and only pick colors that go together.
(defn colorize-rand (string seed count)
    (let (fg-color-vec (vec *fg-default* *fg-red* *fg-green* *fg-yellow* *fg-blue* *fg-magenta* *fg-cyan* *fg-white*)
		random-vec (random-seq (len fg-color-vec) count seed)
		num (% random-vec.0 (len fg-color-vec))
		color fg-color-vec.~num)
		(prn (type num))
        (str color string *fg-default*)))


;;;; Custom imports
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;(panic-display (str-trim (file-to-str "/etc/hostname")))
(load "secrets.slosh")
(import secrets)
(def *hostname* (str-trim (file-to-str "/etc/hostname")))
(def *hostname-secrets* (str *hostname* "-secrets"))
(def *hostname-file* (str "~/.config/slosh/" *hostname* ".slosh"))
(def *hostname-secrets-file* (str "~/.config/slosh/" *hostname-secrets* ".slosh"))
(load *hostname-file*)
(load *hostname-secrets-file*)
(def *hostname-sym* (->sym *hostname*))
(def *hostname-secrets-sym* (->sym *hostname*))
(import *hostname-sym*)
(import *hostname-secrets-sym*)


;;;; Prompt and aliases
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def *ns* "SLOSH")
;; (def tst-hash {:key1  "val one" 'key2 "val two" "key3" "val three" \S "val S"})

#% Usage: ~internal usage~

Current set of git integrations:
${git-prompt-features}

Section: tools
%#
(defn __prompt ()
	(let    (device-specific-seeds {"hiemal"  "All solutions have problems and all problems have solutions!"
					"brumal" "brrr!"
					"frostig" "gen2"}
		flox-val (env "FLOX_PROMPT_ENVIRONMENTS")
		host-val (get-hostname)
		seed-append (get device-specific-seeds host-val)
		host-val (if (nil? seed-append) host-val (str seed-append host-val))
		palettes (color-palette::make-palettes)
		palette-indices (random-seq (len palettes) 2 host-val)

		palette-a (get palettes palette-indices.0)
		palette-a-indices (random-seq (len palette-a) 4 host-val)
		color-namespace (apply fg-color-rgb (get palette-a palette-a-indices.0))
		color-namespace-parens (apply fg-color-rgb (get palette-a palette-a-indices.1))
		color-hostname (apply fg-color-rgb (get palette-a palette-a-indices.2))
		color-prompt (apply fg-color-rgb (get palette-a palette-a-indices.3))

		palette-b (get palettes palette-indices.1)
		palette-b-indices (random-seq (len palette-b) 4 host-val)
		color-pwd (apply fg-color-rgb (get palette-b palette-b-indices.0))
		color-git-branch (apply fg-color-rgb (get palette-b palette-b-indices.1))
		color-pwd-parens (apply fg-color-rgb (get palette-b palette-b-indices.2))
		git-prompt (parse-git-branch)
		__ (str-push! *git-prompt-features* "\n - BRANCH AWARE: Display the current branch in prompt and set BRANCH NAME env var.")
		__ (str-push! *git-prompt-features* "\n - FLOX AWARE: Display the current flox environment(s) vi FLOX_PROMPT_ENVIRONMENTs var.")
		git-prompt (if (and (not (= git-prompt ""))
				(str-contains
					(str-lower ($sh "git stash list --date=relative | head -n 1"))
					"pop"))
				(str *fg-red* ": ~¡¡CHECK STASH!!~" *fg-default* git-prompt)
				git-prompt)
		__ (str-push! *git-prompt-features* "\n - STASH ALERT: If most recent stash message contains the word pop (grep -i) display on prompt")
		color-pwd-parens (apply fg-color-rgb (get palette-b palette-b-indices.2))
		color-flox-val (apply fg-color-rgb (get palette-b palette-b-indices.3)))
	(str
		(if (not (str-empty? flox-val)) (str "\n[[ " color-flox-val flox-val " ]]\n") "")
		color-namespace-parens "["
		color-namespace *ns*
		color-namespace-parens  "]"
		color-namespace ":"
		color-hostname *hostname* ": "
		color-pwd-parens "("
		color-pwd (str-trim! (get-pwd))
		color-pwd-parens ")"
	    color-git-branch git-prompt
		(set-prompt-tail *last-status* color-prompt))))

(sh "alias ls='/bin/ls --color -F'")
(sh "alias ll='/bin/ls --color -Flathr'")
(sh "alias vi=nvim")
(sh "alias vim=nvim")
$(alias tmuxls="tmux list-sessions")
;;(sh "echo CURR_PATH: $PATH")
;;(sh "export PATH=/bin:/usr/local/bin:~/bin:~/.cargo/bin:~/.nix-profile/bin/:/usr/bin/:$PATH")
(sh "export PATH=~/.cargo/bin:/bin:/usr/bin:/usr/local/bin:~/bin:/opt/jetbrains-toolbox:$PATH")
(sh "export LC_ALL=en_US.UTF-8")
;; for burntsishi ucd-generate library
;;(sh "export UCD_DIR=/home/price/unicode/ucd-15.0.0/")
;;(sh "export UCD_DIR=/home/price/unicode2/")


;;;; utility functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;(defmacro sc () $(xclip -selection c))

#% Usage: (altrepo "../path/to/other/repo") || (altrepo)

[Inspired by](https://www.vikingsoftware.com/blog/multiple-git-repositories-in-the-same-tree/)

When called with no arguments unsets GIT_DIR and GIT_WORK_TREE env variables so
git defaults to using the .git directory in the closest parent directory.

When called with 1 argument expands the path and changes the GIT_DIR and GIT_WORK_TREE
environment variables so user can remain in 1 directory but commit files to another.

To avoid git conflicts in the directory make sure to add necessary excludes to `.git/info/exclude`
these are local only so no other users of the repo will see you have added lines here. This allows
the altrepo to have files that the main repo ignores. Similarly putting a `**` type rule in the altrepo
so it ignores all the files in the mainrepo is not a bad idea.


* note!!! might be smarter to just do this with bare repos... Wouldn't be hard to bootstrap a little
system to do so. Create a ~/.local/share directory and store git bare repos there, don't necessarily
need them. Could also add some functions to help manage what the corresponding altrepo even is.
Hopefully mr can help with this.
* note!!! this feature should be mentioned in the environment variable *git-prompt-features* present
in the (doc 'git) output.

Section: tools
%#
(defn altrepo (& args)
	(cond 	((nil? args) (do (unset-env "SLOSH_ALT_REPO") (unset-env "GIT_DIR") (unset-env "GIT_WORK_TREE")))
		((== 1 (len args)) (let (path (str args.0)
					full-path (fs-fullpath path))
			(if (nil? full-path)
				(err "Provided filepath is invalid.")
				(do
					(set-env "SLOSH_ALT_REPO" full-path)
					(set-env "GIT_DIR" (str full-path "/.git"))
					(set-env "GIT_WORK_TREE" (env "PWD"))))))
		(#t (err "Takes 0 arguments to leave altrepo and 1 argument for path to altrepo"))))


;;;; Personal Flavor
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;(syntax-on)

;; i'm fun {{{
(prn "                                           ██╗")
(prn "                                           ██║")
(prn "                                           ██║")
(prn "      ██████████████████████████████████╗  ██║")
(prn "      ██╔═════════════════════════════██║  ██║")
(prn "      ██║                             ██║  ██║")
(prn "███████╗██╗      ███████╗██╗  ██╗     ██║  ██║")
(prn "██╔════╝██║      ██╔════╝██║  ██║     ██║  ██║")
(prn "███████╗██║█████╗███████╗███████║     ██║  ██║")
(prn "╚════██║██║╚════╝╚════██║██╔══██║     ██║  ██║")
(prn "███████║███████╗ ███████║██║  ██║     ██║  ██║")
(prn "╚══════╝╚══════╝ ╚══════╝╚═╝  ╚═╝     ██║  ╚═╝")
(prn " ██╗  ██║                             ██║")
(prn " ██║  ██████████████████████████████████║")
(prn " ██║  ╚═════════════════════════════════╝")
(prn " ██║")
(prn " ██║  ████████████████████████████████████████████╗")
(prn " ██║  ╚═══════════════════════════════════════════╝")
(prn " ██║")
(prn " ╚═╝")

(prn "		Hey, hey, hey. Don't be mean.")
(prn "		We don't have to be mean because,")
(prn "		remember, no matter where you go,")
(prn "		there you are.")
(prn (str "			- Buckaroo Banzai"))
